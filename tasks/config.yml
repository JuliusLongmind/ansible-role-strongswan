---

- block:
  - name: selinux | set permissive value for ipsec_mgmt_t
    selinux_permissive:
      name: ipsec_mgmt_t
      permissive: true

  - name: selinux | set permissive value for ipsec_t
    selinux_permissive:
      name: ipsec_t
      permissive: true

  when: ansible_facts['os_family'] == "RedHat"

- block:
  - name: apparmor | apply charon fix
    command: apparmor_parser -R /etc/apparmor.d/usr.lib.ipsec.charon

  - name: apparmor | apply stroke fix
    command: apparmor_parser -R /etc/apparmor.d/usr.lib.ipsec.stroke

  when: ansible_facts['os_family'] == "Debian"

- block:
  - name: Find a name of letsencrypt domain certificate directory
    find:
      paths: /etc/letsencrypt/live
      recurse: no
      file_type: directory
    register: letsencrypt_found_dir

  - name: set letsencrypt facts 
    set_fact:
      letsencrypt_domain_dir: "{{ letsencrypt_found_dir.files[0].path }}"

  - name: Check if letsencrypt certificate already exists
    stat:
      path: "{{ letsencrypt_domain_dir }}/cert.pem"
    register: letsencrypt_cert

  - name: Create symlinks for letsencrypt certificate
    file:
      src: "{{ item.src }}"
      dest: "{{ item.dest }}"
      state: link
    with_items:
      - { src: "{{ letsencrypt_domain_dir }}/chain.pem", dest: "{{ strongswan_swanctl_config_dir }}/x509ca/strongswanCert.pem" }
      - { src: "{{ letsencrypt_domain_dir }}/fullchain.pem", dest: "{{ strongswan_swanctl_config_dir }}/x509/Cert.pem" }
      - { src: "{{ letsencrypt_domain_dir }}/privkey.pem", dest: "{{ strongswan_swanctl_config_dir }}/private/Key.pem" }
    when: letsencrypt_cert.stat.exists

  - name: fail due to missing letsencrypt certificate
    fail:
      msg: "Error: letsencrypt certificate doesn't exists. Please check your certificate configuration !"
    when: not letsencrypt_cert.stat.exists

  when: strongswan_letsencrypt_enable

- name: Configure Strongswan strongswan.conf
  template:
    src: strongswan.conf.j2
    dest: "{{ strongswan_conf_file }}"
    owner: root
    group: root
    mode: 0644
  when: strongswan_settings is defined

- name: Configure Strongswan swanctl.conf
  template:
    src: swanctl.conf.j2
    dest: "{{ strongswan_swanctl_config_file }}"
    owner: root
    group: root
    mode: 0644
  notify: swanctl restart

- name: Configure forwarding sysctl
  template:
    src: sysctl-conf.j2
    dest: "/etc/sysctl.d/60-strongswan.conf"
    owner: root
    group: root
    mode: 0644
  notify: sysctl reload

- name: Ensure Strongswan service is enabled and started
  systemd:
    name: "{{ strongswan_swanctl_svc }}"
    state: started
    enabled: yes
    daemon_reload: yes

# It's workaround until direct option will be added to firewalld ansible module
# https://github.com/ansible/ansible/pull/49514
- name: Skip NAT for ipsec packets with a matching IPsec policy
  shell: |
    /usr/sbin/iptables -t nat -D POSTROUTING -m policy --pol ipsec --dir out -j ACCEPT
    /usr/sbin/iptables -t nat -I POSTROUTING -m policy --pol ipsec --dir out -j ACCEPT
  when:
    - not strongswan_client
    - iptables_nat_fix
